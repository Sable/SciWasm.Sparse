(module
  (import "js" "mem" (memory 1 32767 shared))
  (import "console" "time" (func $time (result f64)))
  (import "console" "log" (func $logf (param f32)))
  (import "console" "log" (func $logf64 (param f64)))
  (import "console" "log" (func $logi (param i32)))

  (func $spts_csr_sync_free (export "spts_csr_sync_free") (param $id i32) (param $csr_rowptr i32) (param $csr_col i32) (param $csr_val i32) (param $x i32) (param $y i32) (param $len i32) (param $flag i32) (param $nthreads i32)
    (local $i i32)
    (local $j i32)
    (local $stride1 i32)
    (local $stride2 i32)
    (local $current i32)
    (local $random i32)
    (local $end i32)
    (local $temp f32)
    (local.get $len)
    (local.get $id)
    (tee_local $i)
    (i32.le_s)
    if
      (return)
    end
    (local.get $i)
    (i32.const 2)
    (i32.shl)
    (local.set $stride1)
    (local.set $y (i32.add (local.get $y) (local.get $stride1)))
    (local.set $current (i32.add (local.get $flag) (local.get $stride1)))
    (local.set $csr_rowptr (i32.add (local.get $csr_rowptr) (local.get $stride1)))
    (i32.load (local.get $csr_rowptr))
    (i32.const 2)
    (i32.shl)
    (local.set $stride2)
    (local.get $csr_col)
    (local.get $stride2)
    (i32.add)
    (local.set $csr_col)
    (local.get $csr_val)
    (local.get $stride2)
    (i32.add)
    (local.set $csr_val) 
    (local.get $nthreads)
    (i32.const 2)
    (i32.shl)
    (local.set $stride1)
    (loop $outer_loop
      ;; check if there are non-diagonals elements in the row.
      (i32.load (i32.add (local.get $csr_rowptr) (i32.const 4)))
      (tee_local $end)
      (i32.load (local.get $csr_rowptr))
      (i32.const 1)
      (i32.add)
      (tee_local $j)
      (i32.gt_s)
      (if
      (then
        (f32.load (local.get $y))
        (local.set $temp)
        (loop $inner_loop
          (local.get $temp)
          (f32.load (local.get $csr_val))
	  (i32.add (local.get $flag) (i32.shl (i32.load (local.get $csr_col)) (i32.const 2)))
          (local.set $random)
          (loop $wait_loop
            (i32.load (local.get $random))
	    (i32.const 1)
            (i32.ne)
            (br_if $wait_loop)
	  )
          (f32.load (i32.add (local.get $x) (i32.shl (i32.load (local.get $csr_col)) (i32.const 2))))
          (f32.mul)
          (f32.sub)
          (local.set $temp)
          (local.set $csr_col (i32.add (local.get $csr_col) (i32.const 4)))
          (local.set $csr_val (i32.add (local.get $csr_val) (i32.const 4)))
          (tee_local $j (i32.add (local.get $j) (i32.const 1)))
          (local.get $end)
          (i32.ne)
          (br_if $inner_loop)
        )
        ;; Divide by the diagonal element to get final value of y
        (local.get $y)
        (local.get $temp)
        (f32.load (local.get $csr_val))
        (f32.div)
        (f32.store)
        (i32.store (local.get $current) (i32.const 1)) 
      )
      (else
        ;; Divide by the diagonal element to get final value of y
        (local.get $y)
        (f32.load (local.get $y))
        (f32.load (local.get $csr_val))
        (f32.div)
        (f32.store)
        (i32.store (local.get $current) (i32.const 1)) 
      ))
      (local.set $y (i32.add (local.get $y) (local.get $stride1)))
      (local.set $current (i32.add (local.get $current) (local.get $stride1)))
      (local.set $csr_rowptr (i32.add (local.get $csr_rowptr) (local.get $stride1)))
      (i32.load (local.get $csr_rowptr))
      (local.get $end)
      (i32.sub)
      (i32.const 1)
      (i32.add)
      (i32.const 2)
      (i32.shl)
      (local.set $stride2)
      (local.set $csr_col (i32.add (local.get $csr_col) (local.get $stride2)))
      (local.set $csr_val (i32.add (local.get $csr_val) (local.get $stride2)))
      (tee_local $i (i32.add (local.get $i) (local.get $nthreads)))
      (local.get $len)
      (i32.lt_s)
      (br_if $outer_loop)
    )
  )

  (func $spts_csr_sync_free_wrapper (export "spts_csr_sync_free_wrapper") (param $id i32) (param $csr_rowptr i32) (param $csr_col i32) (param $csr_val i32) (param $x i32) (param $y i32) (param $N i32) (param $barrier i32) (param $global_flag i32) (param $flag i32) (param $nthreads i32) (param $inner_max i32)
    (local $i i32)
    (local $j i32)
    (local $len i32)
    (local $temp_x i32)
    (local $temp_y i32)
    (local $temp_flag i32)
    (local $local_flag i32)
    (local.get $inner_max)
    (i32.const 0)
    (tee_local $j)
    (i32.le_s)
    if
      (return)
    end
    (i32.const 0)
    (local.set $local_flag)
    (loop $top
      (local.get $local_flag)
      (i32.eqz)
      (if
      (then
        (i32.const 1)
        (local.set $local_flag)
      )
      (else
        (i32.const 0)
        (local.set $local_flag)
      ))
      ;; each worker thread copies x to y for its asssigned partition.
      (local.get $N)
      (local.get $nthreads)
      (i32.div_u)
      (local.set $len)
      (local.get $len)
      (local.get $id)
      (i32.mul)
      (i32.const 2)
      (i32.shl)
      (local.set $i)
      (i32.add (local.get $y) (local.get $i))
      (local.set $temp_y)
      (i32.add (local.get $x) (local.get $i))
      (local.set $temp_x)
      (i32.add (local.get $flag) (local.get $i))
      (local.set $temp_flag)
      (local.get $nthreads)
      (local.get $id)
      (i32.sub)
      (i32.const 1)
      (i32.eq)
      if
        (local.get $N)
        (local.get $nthreads)
        (i32.rem_u)
        (local.get $len)
        (i32.add)
        (local.set $len)
      end
      (i32.const 0)
      (local.set $i)
      (loop $copy_x_to_y
        (local.get $temp_y)
        (f32.load (local.get $temp_x))
        (f32.store)
        (local.get $temp_flag)
        (i32.const 0)
        (i32.store)
        (local.set $temp_x (i32.add (local.get $temp_x) (i32.const 4)))
        (local.set $temp_y (i32.add (local.get $temp_y) (i32.const 4)))
        (local.set $temp_flag (i32.add (local.get $temp_flag) (i32.const 4)))
        (tee_local $i (i32.add (local.get $i) (i32.const 1)))
        (local.get $len)
        (i32.ne)
        (br_if $copy_x_to_y)
      )
      (i32.const 0)
      (local.set $i)
      (local.get $nthreads)
      (i32.atomic.rmw.add (local.get $barrier) (i32.const 1))
      (i32.sub)
      (i32.const 1)
      (i32.eq)
      (if
      (then
        (i32.store (local.get $barrier) (i32.const 0))
        (i32.atomic.store (local.get $global_flag) (local.get $local_flag))
      )
      (else
        (loop $top_wait_loop
          (i32.load (local.get $global_flag))
          (local.get $local_flag)
          (i32.ne)
          (br_if $top_wait_loop)
        )
      ))
      (local.get $local_flag)
      (i32.eqz)
      (if
      (then
        (i32.const 1)
        (local.set $local_flag)
      )
      (else
        (i32.const 0)
        (local.set $local_flag)
      ))
      (local.get $id)
      (local.get $csr_rowptr)
      (local.get $csr_col)
      (local.get $csr_val)
      (local.get $y)
      (local.get $y)
      (local.get $N)
      (local.get $flag)
      (local.get $nthreads)
      (call $spts_csr_sync_free)
      
      (local.get $nthreads)
      (i32.atomic.rmw.add (local.get $barrier) (i32.const 1)) 
      (i32.sub)
      (i32.const 1)	
      (i32.eq)
      (if
      (then
        (i32.store (local.get $barrier) (i32.const 0)) 
        (i32.atomic.store (local.get $global_flag) (local.get $local_flag)) 
      )
      (else
        (loop $wait_loop
          (i32.load (local.get $global_flag))
          (local.get $local_flag)
          (i32.ne)
          (br_if $wait_loop)
        )
      ))
      (local.get $inner_max)
      (tee_local $j (i32.add (local.get $j) (i32.const 1)))
      (i32.ne)
      (br_if $top)
    )
  )

  (func $spts_csr (export "spts_csr") (param $csr_rowptr i32) (param $csr_col i32) (param $csr_val i32) (param $x i32) (param $y i32) (param $len i32)
    (local $i i32)
    (local $j i32)
    (local $end i32)
    (local $temp f32)
    (local.get $len)
    (i32.const 0)
    (tee_local $i)
    (i32.le_s)
    if
      (return)
    end
    (i32.load (local.get $csr_rowptr))
    (i32.const 2)
    (i32.shl)
    (local.get $csr_col)
    (i32.add)
    (local.set $csr_col)
    (i32.load (local.get $csr_rowptr))
    (i32.const 2)
    (i32.shl)
    (local.get $csr_val)
    (i32.add)
    (local.set $csr_val)
    (loop $outer_loop
      ;; check if there are non-diagonals elements in the row.
      (i32.load (i32.add (local.get $csr_rowptr) (i32.const 4)))
      (i32.const 1)
      (i32.sub)
      (tee_local $end)
      (i32.load (local.get $csr_rowptr))
      (tee_local $j)
      (i32.gt_s)
      (if
      (then
        (f32.load (local.get $y))
        (local.set $temp)
        (loop $inner_loop
          (local.get $temp)
          (f32.load (local.get $csr_val))
          (f32.load (i32.add (local.get $x) (i32.shl (i32.load (local.get $csr_col)) (i32.const 2))))
          (f32.mul)
	  (f32.sub)
          (local.set $temp)
          (local.set $csr_col (i32.add (local.get $csr_col) (i32.const 4)))
          (local.set $csr_val (i32.add (local.get $csr_val) (i32.const 4)))
          (tee_local $j (i32.add (local.get $j) (i32.const 1)))
          (local.get $end)
          (i32.ne)
          (br_if $inner_loop)
        )	 
        ;; Divide by the diagonal element to get final value of y 
        (local.get $y)
        (local.get $temp)
        (f32.load (local.get $csr_val))
        (f32.div)
        (f32.store)
      )
      (else
        ;; Divide by the diagonal element to get final value of y 
        (local.get $y)
        (f32.load (local.get $y))
        (f32.load (local.get $csr_val))
        (f32.div)
        (f32.store)
      ))
      (local.set $csr_rowptr (i32.add (local.get $csr_rowptr) (i32.const 4)))
      (local.set $csr_col (i32.add (local.get $csr_col) (i32.const 4)))
      (local.set $csr_val (i32.add (local.get $csr_val) (i32.const 4)))
      (local.set $y (i32.add (local.get $y) (i32.const 4)))
      (tee_local $i (i32.add (local.get $i) (i32.const 1)))
      (local.get $len)
      (i32.ne)     
      (br_if $outer_loop)
    )
  )

  (func $spts_level_csr (export "spts_level_csr") (param $id i32) (param $level_ptr i32) (param $csr_rowptr i32) (param $csr_col i32) (param $csr_val i32) (param $x i32) (param $y i32) (param $permutation i32) (param $nlevels i32) (param $barrier i32) (param $global_flag i32) (param $nthreads i32) (param $N i32) (param $inner_max i32)
    (local $i i32)
    (local $j i32)
    (local $nrows i32)
    (local $len i32)
    (local $rem i32)
    (local $start i32)
    (local $this_y i32)
    (local $temp_y i32)
    (local $temp_x i32)
    (local $start_level_ptr i32)
    (local $local_flag i32)
    ;; check if the number of levels is less than or equal to zero.
    (local.get $nlevels)
    (i32.const 0)
    (local.tee $i)
    (i32.le_s)
    if
      (return)
    end
    (local.get $inner_max)
    (i32.const 0)
    (tee_local $j)
    (i32.le_s)
    if
      (return)
    end
    (i32.const 0)
    (local.set $local_flag)
    (local.get $level_ptr)
    (local.set $start_level_ptr)
    ;;(call $time)
    ;;(drop)
    (loop $top
      (local.get $local_flag)
      (i32.eqz)
      (if
      (then
	(i32.const 1)
	(local.set $local_flag)
      )
      (else
	(i32.const 0)
	(local.set $local_flag)
      ))
      ;; each worker thread copies x to y for its asssigned partition.
      (local.get $N)
      (local.get $nthreads)
      (i32.div_u)
      (local.set $len)
      (local.get $len)
      (local.get $id)
      (i32.mul)
      (i32.const 2)
      (i32.shl)
      (local.set $i)
      (i32.add (local.get $y) (local.get $i))
      (local.set $temp_y)
      (i32.add (local.get $x) (local.get $i))
      (local.set $temp_x)
      (local.get $nthreads)
      (local.get $id)
      (i32.sub)
      (i32.const 1)
      (i32.eq)
      if
        (local.get $N)
        (local.get $nthreads)
        (i32.rem_u)
	(local.get $len)
        (i32.add)
	(local.set $len)
      end
      (i32.const 0)
      (local.set $i)
      (loop $copy_x_to_y 
        (local.get $temp_y)
        (f32.load (local.get $temp_x))
        (f32.store)
        (local.set $temp_x (i32.add (local.get $temp_x) (i32.const 4)))
        (local.set $temp_y (i32.add (local.get $temp_y) (i32.const 4)))
        (tee_local $i (i32.add (local.get $i) (i32.const 1)))
        (local.get $len)
        (i32.ne)
        (br_if $copy_x_to_y)
      )
      (i32.const 0)
      (local.set $i)
      (local.get $nthreads)
      (i32.atomic.rmw.add (local.get $barrier) (i32.const 1)) 
      (i32.sub)
      (i32.const 1)	
      (i32.eq)
      (if
      (then
        (i32.store (local.get $barrier) (i32.const 0)) 
        (i32.atomic.store (local.get $global_flag) (local.get $local_flag)) 
      )
      (else
        (loop $top_wait_loop
          (i32.load (local.get $global_flag))
          (local.get $local_flag)
          (i32.ne)
          (br_if $top_wait_loop)
        )
      ))
      (loop $level_loop
	(local.get $local_flag)
	(i32.eqz)
	(if
	(then
	  (i32.const 1)
	  (local.set $local_flag)
	)
	(else
	  (i32.const 0)
	  (local.set $local_flag)
	))
        ;; At each level, calculate the rows partition for each thread using id.
        ;; This is to avoid calls (equal to the number of levels) between the master 
        ;; JavaScript thread and worker WebAssembly threads.
        (i32.load (i32.add (local.get $level_ptr) (i32.const 4)))
        (i32.load (local.get $level_ptr))
        (i32.sub)
        (tee_local $nrows)
        (local.get $nthreads)
        (i32.div_u)
        (local.set $len)
      
        (local.get $len)
        (i32.const 0)
        (i32.ne)
        (if
        (then
          (local.get $nrows)
          (local.get $nthreads)
          (i32.rem_u)
	  (tee_local $rem)
	  (local.get $id)
	  (i32.gt_s)
	  (if
	  (then
            (local.set $start (i32.shl (i32.add (i32.load (local.get $level_ptr)) (i32.add (i32.mul (local.get $id) (local.get $len)) (local.get $id))) (i32.const 2)))
            (local.get $len)
	    (i32.const 1)
            (i32.add)	
            (local.set $len)
          )
	  (else
            (local.set $start (i32.shl (i32.add (i32.load (local.get $level_ptr)) (i32.add (i32.mul (local.get $id) (local.get $len)) (local.get $rem))) (i32.const 2)))
	  ))
          (i32.add (local.get $csr_rowptr) (local.get $start)) 
          (local.get $csr_col)
          (local.get $csr_val)
          (local.get $y)
          (i32.add (local.get $y) (local.get $start)) 
          (local.get $len)
          (call $spts_csr)
        )
        (else
          (local.get $nrows) 
	  (local.get $id)
	  (i32.gt_s)
	  if
	    (i32.const 1)
	    (local.set $len)
            (local.set $start (i32.shl (i32.add (i32.load (local.get $level_ptr)) (i32.mul (local.get $id) (local.get $len))) (i32.const 2)))
            (i32.add (local.get $csr_rowptr) (local.get $start)) 
            (local.get $csr_col)
            (local.get $csr_val)
            (local.get $y)
            (i32.add (local.get $y) (local.get $start)) 
            (local.get $len)
            (call $spts_csr)
	  end
        ))
        ;; Increment the barrier value using atomic read-modify-write operation 
        ;; (returns value read from memory before the modify operation was performed).
        (local.get $nthreads)
        (i32.atomic.rmw.add (local.get $barrier) (i32.const 1)) 
	(i32.sub)
        (i32.const 1)	
	(i32.eq)
	(if
	(then
          (i32.store (local.get $barrier) (i32.const 0)) 
          (i32.atomic.store (local.get $global_flag) (local.get $local_flag)) 
	)
        (else
          (loop $wait_loop
            (i32.load (local.get $global_flag))
            (local.get $local_flag)
            (i32.ne)
            (br_if $wait_loop)
          )
        ))
        (local.set $level_ptr (i32.add (local.get $level_ptr) (i32.const 4)))
        (tee_local $i (i32.add (local.get $i) (i32.const 1)))
        (local.get $nlevels)
        (i32.ne)     
        (br_if $level_loop)
      )
      (local.get $start_level_ptr)
      (local.set $level_ptr)
      (local.get $inner_max)
      (tee_local $j (i32.add (local.get $j) (i32.const 1)))
      (i32.ne)
      (br_if $top)
    )
  )

  (func $spts_csr_level_sync_free (export "spts_csr_level_sync_free") (param $csr_rowptr i32) (param $csr_col i32) (param $csr_val i32) (param $x i32) (param $y i32) (param $len i32) (param $current i32) (param $flag i32)
    (local $i i32)
    (local $j i32)
    (local $end i32)
    (local $random i32)
    (local $temp f32)
    (local.get $len)
    (i32.const 0)
    (tee_local $i)
    (i32.le_s)
    if
      (return)
    end
    (i32.load (local.get $csr_rowptr))
    (i32.const 2)
    (i32.shl)
    (local.get $csr_col)
    (i32.add)
    (local.set $csr_col)
    (i32.load (local.get $csr_rowptr))
    (i32.const 2)
    (i32.shl)
    (local.get $csr_val)
    (i32.add)
    (local.set $csr_val)
    (loop $outer_loop
      ;; check if there are non-diagonals elements in the row.
      (i32.load (i32.add (local.get $csr_rowptr) (i32.const 4)))
      (i32.const 1)
      (i32.sub)
      (tee_local $end)
      (i32.load (local.get $csr_rowptr))
      (tee_local $j)
      (i32.gt_s)
      (if
      (then
        (f32.load (local.get $y))
        (local.set $temp)
        (loop $inner_loop
          (local.get $temp)
          (f32.load (local.get $csr_val))
	  (i32.add (local.get $flag) (i32.shl (i32.load (local.get $csr_col)) (i32.const 2)))
          (local.set $random)
          (loop $wait_loop
            (i32.load (local.get $random))
            (i32.const 1)
            (i32.ne)
            (br_if $wait_loop)
          )
          (f32.load (i32.add (local.get $x) (i32.shl (i32.load (local.get $csr_col)) (i32.const 2))))
          (f32.mul)
          (f32.sub)
          (local.set $temp)
          (local.set $csr_col (i32.add (local.get $csr_col) (i32.const 4)))
          (local.set $csr_val (i32.add (local.get $csr_val) (i32.const 4)))
          (tee_local $j (i32.add (local.get $j) (i32.const 1)))
          (local.get $end)
          (i32.ne)
          (br_if $inner_loop)
        )
        ;; Divide by the diagonal element to get final value of y
        (local.get $y)
        (local.get $temp)
        (f32.load (local.get $csr_val))
        (f32.div)
        (f32.store)
        (i32.store (local.get $current) (i32.const 1)) 
      )
      (else
        ;; Divide by the diagonal element to get final value of y
        (local.get $y)
        (f32.load (local.get $y))
        (f32.load (local.get $csr_val))
        (f32.div)
        (f32.store)
        (i32.store (local.get $current) (i32.const 1)) 
      ))
      (local.set $csr_rowptr (i32.add (local.get $csr_rowptr) (i32.const 4)))
      (local.set $csr_col (i32.add (local.get $csr_col) (i32.const 4)))
      (local.set $csr_val (i32.add (local.get $csr_val) (i32.const 4)))
      (local.set $y (i32.add (local.get $y) (i32.const 4)))
      (local.set $current (i32.add (local.get $current) (i32.const 4)))
      (tee_local $i (i32.add (local.get $i) (i32.const 1)))
      (local.get $len)
      (i32.ne)
      (br_if $outer_loop)
    )
  )



  (func $spts_csr_level_sync_free_wrapper (export "spts_csr_level_sync_free_wrapper") (param $id i32) (param $level_ptr i32) (param $csr_rowptr i32) (param $csr_col i32) (param $csr_val i32) (param $x i32) (param $y i32) (param $permutation i32) (param $nlevels i32) (param $barrier i32) (param $global_flag i32) (param $flag i32) (param $nthreads i32) (param $N i32) (param $inner_max i32)
    (local $i i32)
    (local $j i32)
    (local $nrows i32)
    (local $len i32)
    (local $rem i32)
    (local $start i32)
    (local $this_y i32)
    (local $temp_y i32)
    (local $temp_x i32)
    (local $temp_flag i32)
    (local $start_level_ptr i32)
    (local $local_flag i32)
    ;; check if the number of levels is less than or equal to zero.
    (local.get $nlevels)
    (i32.const 0)
    (local.tee $i)
    (i32.le_s)
    if
      (return)
    end
    (local.get $inner_max)
    (i32.const 0)
    (tee_local $j)
    (i32.le_s)
    if
      (return)
    end
    (i32.const 0)
    (local.set $local_flag)
    (local.get $level_ptr)
    (local.set $start_level_ptr)
    ;;(call $time)
    ;;(drop)
    (loop $top
      (local.get $local_flag)
      (i32.eqz)
      (if
      (then
        (i32.const 1)
        (local.set $local_flag)
      )
      (else
        (i32.const 0)
        (local.set $local_flag)
      ))
      ;; each worker thread copies x to y for its asssigned partition.
      (local.get $N)
      (local.get $nthreads)
      (i32.div_u)
      (local.set $len)
      (local.get $len)
      (local.get $id)
      (i32.mul)
      (i32.const 2)
      (i32.shl)
      (local.set $i)
      (i32.add (local.get $y) (local.get $i))
      (local.set $temp_y)
      (i32.add (local.get $x) (local.get $i))
      (local.set $temp_x)
      (i32.add (local.get $flag) (local.get $i))
      (local.set $temp_flag)
      (local.get $nthreads)
      (local.get $id)
      (i32.sub)
      (i32.const 1)
      (i32.eq)
      if
        (local.get $N)
        (local.get $nthreads)
        (i32.rem_u)
        (local.get $len)
        (i32.add)
        (local.set $len)
      end
      (i32.const 0)
      (local.set $i)
      (loop $copy_x_to_y
        (local.get $temp_y)
        (f32.load (local.get $temp_x))
        (f32.store)
        (local.get $temp_flag)
        (i32.const 0)
        (i32.store)
        (local.set $temp_x (i32.add (local.get $temp_x) (i32.const 4)))
        (local.set $temp_y (i32.add (local.get $temp_y) (i32.const 4)))
        (local.set $temp_flag (i32.add (local.get $temp_flag) (i32.const 4)))
        (tee_local $i (i32.add (local.get $i) (i32.const 1)))
        (local.get $len)
        (i32.ne)
        (br_if $copy_x_to_y)
      )
      (i32.const 0)
      (local.set $i)
      (local.get $nthreads)
      (i32.atomic.rmw.add (local.get $barrier) (i32.const 1))
      (i32.sub)
      (i32.const 1)
      (i32.eq)
      (if
      (then
        (i32.store (local.get $barrier) (i32.const 0))
        (i32.atomic.store (local.get $global_flag) (local.get $local_flag))
      )
      (else
        (loop $top_wait_loop
          (i32.load (local.get $global_flag))
          (local.get $local_flag)
          (i32.ne)
          (br_if $top_wait_loop)
        )
      ))
      (local.get $local_flag)
      (i32.eqz)
      (if
      (then
        (i32.const 1)
        (local.set $local_flag)
      )
      (else
        (i32.const 0)
        (local.set $local_flag)
      ))
      (loop $level_loop
        ;; At each level, calculate the rows partition for each thread using id.
        ;; This is to avoid calls (equal to the number of levels) between the master
        ;; JavaScript thread and worker WebAssembly threads.
        (i32.load (i32.add (local.get $level_ptr) (i32.const 4)))
        (i32.load (local.get $level_ptr))
        (i32.sub)
        (tee_local $nrows)
        (local.get $nthreads)
        (i32.div_u)
        (local.set $len)

        (local.get $len)
        (i32.const 0)
        (i32.ne)
        (if
        (then
          (local.get $nrows)
          (local.get $nthreads)
          (i32.rem_u)
          (tee_local $rem)
          (local.get $id)
          (i32.gt_s)
          (if
          (then
            (local.set $start (i32.shl (i32.add (i32.load (local.get $level_ptr)) (i32.add (i32.mul (local.get $id) (local.get $len)) (local.get $id))) (i32.const 2)))
            (local.get $len)
            (i32.const 1)
            (i32.add)
            (local.set $len)
          )
          (else
            (local.set $start (i32.shl (i32.add (i32.load (local.get $level_ptr)) (i32.add (i32.mul (local.get $id) (local.get $len)) (local.get $rem))) (i32.const 2)))
          ))
          (i32.add (local.get $csr_rowptr) (local.get $start))
          (local.get $csr_col)
          (local.get $csr_val)
          (local.get $y)
          (i32.add (local.get $y) (local.get $start))
          (local.get $len)
          (i32.add (local.get $flag) (local.get $start))
          (local.get $flag)
          (call $spts_csr_level_sync_free)
        )
	(else
          (local.get $nrows)
          (local.get $id)
          (i32.gt_s)
          if
            (i32.const 1)
            (local.set $len)
            (local.set $start (i32.shl (i32.add (i32.load (local.get $level_ptr)) (i32.mul (local.get $id) (local.get $len))) (i32.const 2)))
            (i32.add (local.get $csr_rowptr) (local.get $start))
            (local.get $csr_col)
            (local.get $csr_val)
            (local.get $y)
            (i32.add (local.get $y) (local.get $start))
            (local.get $len)
            (i32.add (local.get $flag) (local.get $start))
            (local.get $flag)
            (call $spts_csr_level_sync_free)
          end
        ))
        (local.set $level_ptr (i32.add (local.get $level_ptr) (i32.const 4)))
        (tee_local $i (i32.add (local.get $i) (i32.const 1)))
        (local.get $nlevels)
        (i32.ne)
        (br_if $level_loop)
      )
      ;; Increment the barrier value using atomic read-modify-write operation
      ;; (returns value read from memory before the modify operation was performed).
      (local.get $nthreads)
      (i32.atomic.rmw.add (local.get $barrier) (i32.const 1))
      (i32.sub)
      (i32.const 1)
      (i32.eq)
      (if
      (then
        (i32.store (local.get $barrier) (i32.const 0))
        (i32.atomic.store (local.get $global_flag) (local.get $local_flag))
      )
      (else
        (loop $wait_loop
          (i32.load (local.get $global_flag))
          (local.get $local_flag)
          (i32.ne)
          (br_if $wait_loop)
        )
      ))
      (local.get $start_level_ptr)
      (local.set $level_ptr)
      (local.get $inner_max)
      (tee_local $j (i32.add (local.get $j) (i32.const 1)))
      (i32.ne)
      (br_if $top)
    )
  )
)

